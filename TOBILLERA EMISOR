#include <WiFi.h>              // Librería WiFi del ESP32
#include <esp_now.h>           // Librería para usar ESP-NOW
#include <esp_wifi.h>          // Librería donde se define wifi_tx_info_t

#include <Wire.h>              // Librería para el bus I2C
#include <Adafruit_Sensor.h>   // Librería base de Adafruit para sensores
#include <Adafruit_BMP280.h>   // Librería para el sensor BMP280 (presión/altitud)
#include <Adafruit_MPU6050.h>  // Librería para el sensor MPU6050 (IMU)

// ====== OBJETOS DE LOS SENSORES ======
Adafruit_BMP280 bmp;       // Objeto para manejar el BMP280 (barómetro y altímetro)
Adafruit_MPU6050 mpu;      // Objeto para manejar el MPU6050 (acelerómetro + giroscopio)

// ====== PIN DEL MOTOR VIBRADOR ======
const int motorPin = 25;   // Pin digital donde está conectado el módulo vibrador

// ====== VARIABLES DE REFERENCIA ======
float altitudBase = 0;     // Variable para guardar la altitud inicial como referencia
bool calibrado = false;    // Bandera para indicar si ya se calibró la altitud base

// ====== MAC DEL BRAZALETE (RECEPTOR) ======
// Dirección MAC del brazalete receptor (ESP32 que recibe los datos)
uint8_t macBrazalete[] = {0xB0, 0xB2, 0x1C, 0xA8, 0xFF, 0xB8};

// ====== ESTRUCTURA DE DATOS A ENVIAR POR ESP-NOW ======
// Definimos una estructura con los datos que enviaremos al brazalete
typedef struct __attribute__((packed)) {
  float cadencia;       // Cadencia estimada (pasos por minuto)
  float presion;        // Presión atmosférica en hPa
  float altitud;        // Altitud actual en metros
  float deltaAltitud;   // Diferencia de altitud respecto a la altitud base
} TobilleraData;

// Creamos una variable de tipo TobilleraData para enviar en cada ciclo
TobilleraData dato;

// ====== CALLBACK DE ENVÍO (FIRMA NUEVA PARA EL CORE ESP32) ======
// Esta función se ejecuta automáticamente después de cada envío por ESP-NOW
// info: información sobre la transmisión (no la usamos aquí)
// status: indica si el envío fue exitoso o falló
void onDataSent(const wifi_tx_info_t *info, esp_now_send_status_t status) {
  (void)info; // Se marca como no usado para evitar advertencias del compilador

  Serial.print("ESP-NOW envio -> ");                          // Mensaje de debug
  Serial.println(status == ESP_NOW_SEND_SUCCESS ? "EXITO"     // Imprime EXITO si el envío fue correcto
                                                : "FALLO");   // Imprime FALLO si hubo error
}

void setup() {
  Serial.begin(115200);        // Inicia el puerto serie a 115200 baudios
  Wire.begin();                // Inicia el bus I2C
  pinMode(motorPin, OUTPUT);   // Configura el pin del motor como salida
  digitalWrite(motorPin, LOW); // Asegura que el motor empiece apagado

  Serial.println("Iniciando sensores (tobillera)...");

  // --- Inicializar MPU6050 ---
  if (!mpu.begin()) {                                             // Intenta iniciar el MPU6050
    Serial.println("No se detecta el sensor MPU6050. Verifique conexiones SDA/SCL.");
    while (1);                                                    // Si falla, se queda aquí bloqueado
  }

  // --- Inicializar BMP280 ---
  if (!bmp.begin(0x76)) {                                         // Intenta iniciar el BMP280 en la dirección I2C 0x76
    Serial.println("No se detecta el sensor BMP280. Revise la direccion I2C.");
    while (1);                                                    // Si falla, se queda aquí bloqueado
  }

  // --- Configurar IMU ---
  mpu.setAccelerometerRange(MPU6050_RANGE_8_G);                   // Configura rango del acelerómetro a ±8 g
  mpu.setGyroRange(MPU6050_RANGE_500_DEG);                        // (opcional) rango del giroscopio, aquí 500 °/s
  mpu.setFilterBandwidth(MPU6050_BAND_21_HZ);                     // Filtro de ancho de banda para suavizar lecturas

  // --- Mensaje de éxito ---
  Serial.println("Tobillera inicializada correctamente.");
  Serial.println("Mantenga el dispositivo quieto unos segundos para calibrar altitud base...");

  delay(2000);                                                    // Espera 2 segundos para que el sensor se estabilice
  altitudBase = bmp.readAltitude(1013.25);                        // Lee la altitud base usando una presión de referencia
  calibrado = true;                                               // Marca que ya se calibró
  Serial.print("Altitud base registrada: ");
  Serial.print(altitudBase, 2);                                   // Imprime la altitud base con 2 decimales
  Serial.println(" m");

  // ====== INICIALIZAR ESP-NOW COMO EMISOR ======
  WiFi.mode(WIFI_STA);                                            // Coloca el WiFi en modo estación (requerido por ESP-NOW)

  if (esp_now_init() != ESP_OK) {                                 // Inicializa ESP-NOW y verifica si funcionó
    Serial.println("Error iniciando ESP-NOW");
    return;                                                       // Sale de setup si hubo error
  }

  // Registrar callback de envío
  esp_now_register_send_cb(onDataSent);                           // Registra la función onDataSent para saber el resultado de cada envío

  // Registrar al brazalete como peer
  esp_now_peer_info_t peerInfo = {};                              // Crea una estructura para el peer y la inicializa en cero
  memcpy(peerInfo.peer_addr, macBrazalete, 6);                    // Copia la MAC del brazalete en la estructura
  peerInfo.channel = 0;                                           // Usa el canal por defecto (0 = actual)
  peerInfo.encrypt = false;                                       // Indica que no se usará cifrado

  if (esp_now_add_peer(&peerInfo) != ESP_OK) {                    // Añade el brazalete como peer para poder enviarle datos
    Serial.println("Error añadiendo peer (brazalete)");
  } else {
    Serial.println("Peer (brazalete) anadido a ESP-NOW");
  }
}

void loop() {
  sensors_event_t a, g, temp;                                     // Estructuras para eventos de acelerómetro, giroscopio y temperatura interna
  mpu.getEvent(&a, &g, &temp);                                    // Lee los eventos del MPU6050

  // --- Calculo de cadencia simulada (basada en movimiento del eje Y) ---
  float cadencia = abs(a.acceleration.y) * 10;                    // Calcula una cadencia aproximada a partir de la aceleración en Y
  Serial.print("Cadencia estimada: ");
  Serial.print(cadencia, 1);                                      // Imprime la cadencia con 1 decimal
  Serial.println(" pasos/min");

  // --- Lectura del barometro ---
  float presion = bmp.readPressure() / 100.0;                     // Lee la presión en Pa y la convierte a hPa dividiendo entre 100
  float altitud = bmp.readAltitude(1013.25);                      // Calcula la altitud actual usando la presión de referencia
  float deltaAltitud = altitud - altitudBase;                     // Diferencia entre altitud actual y altitud base

  Serial.print("Presion: ");
  Serial.print(presion);                                          // Imprime la presión en hPa
  Serial.print(" hPa | Altitud actual: ");
  Serial.print(altitud, 2);                                       // Imprime la altitud actual con 2 decimales
  Serial.print(" m | Diferencia: ");
  Serial.print(deltaAltitud, 2);                                  // Imprime la diferencia de altitud
  Serial.println(" m");

  // --- Control del motor vibrador segun desnivel ---
  if (abs(deltaAltitud) > 2.0) {                                  // Si la diferencia de altitud es mayor a 2 metros (subida o bajada)
    digitalWrite(motorPin, HIGH);                                 // Enciende el motor vibrador
    Serial.println("Desnivel detectado -> Vibracion activada");
  } else {
    digitalWrite(motorPin, LOW);                                  // Mantiene el motor apagado si no hay desnivel significativo
  }

  // ====== RELLENAR ESTRUCTURA Y ENVIAR POR ESP-NOW ======
  dato.cadencia = cadencia;                                       // Guarda la cadencia en la estructura a enviar
  dato.presion = presion;                                         // Guarda la presión
  dato.altitud = altitud;                                         // Guarda la altitud actual
  dato.deltaAltitud = deltaAltitud;                               // Guarda la diferencia de altitud

  // Envia la estructura al brazalete usando ESP-NOW
  esp_err_t result = esp_now_send(macBrazalete,                   // Dirección MAC de destino (brazalete)
                                  (uint8_t *)&dato,               // Puntero a los datos a enviar (cast a uint8_t*)
                                  sizeof(dato));                  // Tamaño en bytes de la estructura

  if (result == ESP_OK) {                                         // Si el resultado fue correcto
    Serial.println("Datos enviados al brazalete");
  } else {                                                         
    Serial.print("Error al enviar datos: ");                       // Si hubo error, muestra el código de error
    Serial.println(result);
  }

  Serial.println("-------------------------------");          // Separador visual en el monitor serie
  delay(1000);                                                     // Espera 1 segundo antes de la siguiente medición y envío
}
